# 代码重用  
* 重用类代码  
	* 用类定义对象  
	* 通过组合定义新的类（称为组合类）
	* 通过继承定义新的类（称为派生类）
* 类的五大要素  
	* 数据成员  
	* 函数成员  
	* 访问权限   
	* 构造函数  
	* 析构函数  
# 类的组合  
* 组合的编程原理是：程序员在定义新类的时候，使用已有的类来定义数据成员。执行数据成员是类类型的对象，被称为类的**对象成员**。c++语言将数据成员中包含对象成员的类称为组合类  
* 按照数据类型的不同，组合类中数据成员可分为2种，即类类型的**对象成员**和级别数据类型的**非对象成员**  
* 使用组合类定义对象，即组合类对象，其成员中也将包含对象成员和非对象成员  
* 访问组合类对象中的非对象成员`组合类对象名.非对象成员名`   
* 组合类对象中的对象成员还包括自己的下级成员，也就是说组合类对象包含多级成员。可以访问组合类对象中对象成员的下级成员，这是一种多级访问。多级访问的语法形式是：`组合类对象名.对象成员名.对象成员的下级成员名`  
* 多级访问将受到多级权限的控制  
* 如何设计组合类中对象成员范围权限  
	* 组合类编程中有2种程序员角色，分别是定义组合类的程序员甲和使用组合类的程序员乙  
	* 甲在使用对象成员组装组合类时，可根据功能要求决定将哪些对象成员开放给乙，哪些隐藏起来。开放就是将对象成员设定为公有权限，隐藏就是设定为保护权限或所有权限，这就是对象成员的二次封装  
	* 乙使用组合类定义对象。在所定义出的组合类对象中，开放的对象成员可以访问，隐藏的则不可以访问。组合类对象中的对象成员还包含下级成员，这些下级成员也都有各自的访问权限，公有的才可以访问，否则不可以  
	* 多级访问将受到多级权限控制。访问组合类对象中对象成员的下级成员，只有对象成员和下级成员都是公有权限才可以访问，否则就不能访问   
* 组合类对象的构造与析构  
	* 对象的构造与析构  
	> 计算机执行定义对象语句时将创建对象，为其分配内存空间，并自动调用对象所属类的构造函数来初始化对象，这个过程就是对象的构造。当对象生存期结束时，计算机将销毁对象。销毁时自动调用对象所属类的析构函数来清理内存，然后释放其所占用的内存空间，这个过程就是对象的析构  	  
	* 组合类对象的构造与析构
		* 组合类的构造函数（先构造对象成员后构造非对象成员）  
		```  
		组合类构造函数名(形参列表):对象成员名1(形参1),对象成员名2(形参),......     //对象成员名里的形参来源形参列表    
		{
		......//在函数体中初始化其他非对象成员  
		}  
		```  
		* 组合类对象中各数据成员的初始化顺序是：先调用对象成员所属类的构造函数，初始化对象成员；再执行组合类构造函数的函数体，初始化其他非对象成员  
		* 如果组合类中有多个对象成员，那么这些对象成员的初始化顺序由其在组合类中的声明顺序决定，先声明者先初始化    

* 组合类的析构函数  
	* 当对象生存期结束时，计算机销毁对象，释放其内存空间，这个过程就是对象的析构。销毁对象时计算机会自动调用其所属类的析构函数  
	* 组合类对象中数据成员的析构顺序是：先执行组合类析构函数的函数体，清理非对象成员；再第哦啊有对象成员所属类的析构函数，清理对象成员  
	* 简单地说，对象的析构顺序与构造顺序相反，即先析构非对象成员，再析构对象成员   
* 类的组合与聚合  
	* 数据成员中包含对象成员的类称为组合类  
	* 数据成员中包含对象指针的类称为聚会类，聚合类是一种特殊形式的组合类   
* 聚合类与组合类的区别  
	* 集合类的对象成员是独立创建的，聚合类对象只包含指向对象成员的指针  
	* 聚合类对象可以共用对象成员   
* 组合类总结  
	* **代码重用** 组合类是一种有效的代码重用形式。程序员再设计新类的时候应先去了解有哪些可以重用的类。这些类可以是自己以前编写的，可以是集成开放环境IDE提供的，也可以是从市场上购买的。根据功能选择自己需要的类，然后用组合的方法定义新类   
	* **自低向上** 类可以多级组合。用零件类定义组合类，组合类可继续作为零件类去定义更大的组合类，这就是类的多级组合。多级组合是一种“自底向上”的程序设计方法。类越往上组合，其功能就越有针对性，应用面也就越窄。多级组合过程中，每一级组合类都会根据自己的功能需要设定对象成员的访问权限。有多少级组合，就有多少层封装    


# 类的继承与派生 
* 设计新类时可继承已有的类，这个已有的类被称为基类或父类  
* 基类是为解决以前的老问题而设计的，在面对新问题时其功能可能会显得不够完善。程序员需要在继承的基础上对基类进行派生，例如添加新功能，或者对从基类继承来的功能进行某些修改。派生的目的是为了解决新问题  
* 通过继承与派生所得到的新类被称为派生类或子类  
* 继承与派生的编程原理是：程序员在定义新类的时候，首先继承基类的数据成员和函数成员；在此基础上进行派生，为派生类添加新成员，或对从基类继承来的成员进行重新定义或修改其访问权限。在继承与派生的过程中，继承实现了基类代码的重用，派生则实现了基类代码的进化   
* 派生类中的成员可分为2种：一是从基类继承类的成员，称为派生类中的基类成员，二是定义时新增的成员，称为派生类中的新增成员  
* 定义派生类  
```c++  
class 派生类名:继承方式1 基类1,继承方式2 基类2，.......//派生类声明部分   
{
public:
	新增公有成员  
protected:
	新增包含成员  
private:
        新增私有成员   
}:
各新增函数成员的完整定义//派生类实现部分 
``` 
> * 定义派生类时，在派生类名的后面添加**继承列表**,在声明部分的大括号里声明**新增成员**，在实现部分编写各新增函数成员的完整定义代码；  
> * **继承列表**指定派生类从哪些基类继承。派生类可以只从一个基类继承（单继承），也可以从多个基类继承（多继承）。每个基类以“继承方式 基类名”的形式声明，多个基类之间用“,”隔开；  
> * 派生类将继承基类中**除构造函数、析构函数之外**的所有数据成员和函数成员。基类的构造函数和析构函数也不被继承，派生类需重新编写自己的构造函数|析构函数。    
> * 继承后，派生类会对其基类成员按照**继承方式**进行再次封装。继承方式有3种：publice(公有继承)、protected（保护继承）和private（私有继承）；  
> * public（公有继承）：派生类对其基类成员不做任何封装，他们在派生类中的访问权限与原来在基类的权限相同；  
> * private （私有继承）：派生类对其基类成员做全封装，他们在派生类中的访问权限统统被改为private（私有权限），不管它们原来在基类中的去啊那些是声明。使用私有继承，实际上是派生类要将其基类成员全部隐藏清理；  
> * protected（保护继承）：派生类对其基类成员做半封装。基类中的public成员被继承到派生类后，其访问权限被降格成protected（保护权限）。基类中的protected、private成员被继承到派生类后，其访问权限保持不变；  
> * 在**类声明部分**的大部分中声明新增的数据成员、函数成员，并指定各新增成员的访问权限。在类实现部分编写各新增函数成员的完整定义代码。  
* 同名覆盖:派生类中定义与基类成员重名的新增成员，新增成员将覆盖基类成员。通过成员名访问时，访问到的将是新增成员，这就是新增成员对基类成员的同名覆盖。同名覆盖后，被覆盖的基类成员仍然存在，只是被隐藏了。可以访问被覆盖的基类成员，其访问形式是：基类名::基类成员名     
* 如何数据派生类的继承方式  
	* 派生类编程中有2种程序员角色，分别是定义派生类的程序员甲和使用派生类的程序员乙。甲在设计派生类时需根据派生类的功能要求来决定：是将基类成员继续开放给乙，还是将它们隐藏起来。公有继承就是继续开放基类成员，私有继承或保护继承就是隐藏基类成员，这就是派生类对基类成员的二次封装  
	* 乙使用派生类定义对象，是否可以访问其中的基类成员，这取决于给基类成员的访问权限。派生类类对象中基类成员的访问权限由如下两个方面的因素决定：
		* 因素1：派生类的继承方式  
		* 因素2：基类成员原来在基类中的访问权限  
	* 派生类也可以任意多级。用基类定义派生类，派生类可以继续作为基类去定义更下级的派生类，这就是多级派生。多级派生过程中，每一级派生类都会根据自己的功能需要设定继承方式，这相当于对所继承的基类成员进行再次封装   
* 派生类的**保护继承**是向其下级派生类定向开放的一种半封装   
* 派生类对象的构造与析构  
	* 对象的构造与析构  
	> 计算机执行定义对象语句时将创建对象，为其分配内存空间，并自动调用对象所属类的构造还是来初始化对象，这个过程就是对象的构造。当对象生存期结束时，计算机将销毁对象。销毁时自动调用对象所属类的析构函数来清理内存，然后释放其所占用的内存空间，这个过程就是对象的析构   
* 派生类对象的构造与析构
	* 派生类的构造函数   
	```  
	派生类构造函数名(形参列表):基类名1(形参1),基类名2(形参2),......  
	{
	......//函数体中的初始化新增成员  
	}  
	```   
	> * 派生类对象各数据成员的初始化顺序时：先调用基类构造函数，初始化基类成员；再执行派生类构造函数的函数体，初始化新增成员   
	> * 如果派生类继承了多个基类，那么各基类成员的初始化顺序由其在派生了继承列表中的声明顺序决定，声明在前的基类成员先初始化   
* 派生类的析构函数  
	* 派生类对象中数据成员的析构顺序是：先执行派生类析构函数的函数体，清理新增成员；再调用基类析构函数，清理基类成员。简单来说，对象的析构顺序与构造顺序相反，即先析构新增成员，再析构基类成员  
* 组合派生类的构造与析构  
	* 从基类继承来的成（基类成员），二是新增的对象，三是新增的对象成员   
	* 组合派生类的构造函数需依次初始化基类成员、新增非对象成员。其中，初始化基类成员和新增对象从需通过初始化列表，初始化新增的非对象成员则是再函数体中直接赋值  
	* 组合派生类对象中各成员的析构顺序与其构造顺序相反，即先析构新增的非对象成员，再析构新增对象成员，最后才析构基类成员   

# 多态性  
* 多态性也是一个生物学概念，指的是生物会在不同层面上题型出多态性   
* 源程序中相同的程序元素可能会具有不同的语法解释，c++语言称这些元素具有多态性  
	* 关键字多态性、重载函数多态、运算符多态、对象多态、参数多态  
* 对具有多态性的程序元素作出最终明确的语法解释，这称为多态的实现  
* 不同多态形式具有不同的实现时间点，编译时实现的多态称为编译时多态，执行时实现的多态称为执行时多态  
* 重新定义c++语言已有运算符的运算规则，使同一运算符作用于不同类型时间时执行不同的运算，这就是运算符重载  
	* 程序员可以为类重载运算符，实现类运算  
	* 重载运算符使用函数的形式来定义运算符的运算规则  
``` 
函数类型 operator 运算符(形式参数) 
{  函数体 }  
``` 
	* 将运算符函数定义为类的函数成员  
	* 定义为类外的一个友元函数  
* 运算符重载的语法细则：
	* 除了下面的5个运算符，c++语言中的其他运算符都可以重载。5个不能重载的运算符时：条件运算符“?:"、sizeof运算符、成员运算符“.”、指针运算符“*”和作用域运算符“::”   
	* 重载后，运算符的优先级和结合性不会变   
	* 重载后，运算符的操作数个数不能改变，同时至少要有一个操作数是自定义数据类型  
	* 重载后，运算符的含义应与原运算符相似，否则会给使用类的程序员造成困惑   
* 对象的替换与多态  
	* 派生类是一种基类， 具有基类的所有功能  
	* 面对对象程序设计利用派生类和基类之间的这种特殊关系，常常将派生类对象当作基类对象来使用，或者用基类来代表派生类，其目的是为提高程序代码的可重用性   
* 对象的换与多态  
	* 在面对对象程序设计中，重用处理基类对象的程序代码来处理派生了对象，这是非常普遍的需求  
	* 如果派生类对象能够与基类对象一起共用程序代码，它将极大地提高程序开发和维护的效率  
	* 面对对象程序设计方法利用派生类和基类之间存在的特殊关系，提出了对象的替换与多态  
		* Liskov替换准则：将派生类对象当作基类对象来使用  
		* 对象多态性：用基类来代表派生类     
* 基类及其下面的各级派生类共同组成了一个具有继承关系和共同特性的类的家族，我们称之为族类   
* Liskov替换准则    
	*为了让基类对象及其派生类对象之间可以重用代码，c++语言制定了如下的类型兼容语法规则：  	  
	> * 派生了对象可以赋值给基类对象；  
	> * 派生类的对象可以初始化基类引用；  
	> * 派生类对象的地址可以赋值给基类的对象指针，或者说基类的对象指针可以指向派生类对象。   
	* 应用类型兼容语法规则有1格前提条件和1个使用限制：  
	> * 前提条件：派生了必须公有继承基类。  
	> * 使用限制：通过基类对象、引用或对象指针访问派生类对象，只能访问其基类成员     
* 什么是对象多态性   
	* 面向对象程序设计借用拟人化的说法，将调用对象的某个函数成员称为向对象发送一条消息   
	* 将执行函数成员完成某种程序功能称为对象响应该消息所表现的行为  
	* 不同对象接收相同的消息，但会表现出不同的行为，这就称对象的多态性，或称对象具有多态性   
	* 从程序角度，对象多态性就是：调用不同对象的同名函数成员，但所执行的函数不同，完成的程序功能不同。导致对象多态性同名函数成员有3种不同形式：  
		* 不同类之间的同名函数成员。类成员具有类作用域，不同类之间的函数成员可以重名，互不干扰。   
		* 类中的重载函数。类中的函数成员之间可以重名，只要他们的形参个数不同，或类型不带。重载函数成员导致多态在本质上属于重载函数多态。    
		* 派生了中的他们覆盖。派生类中新增的函数成员可以与从基类继承类的函数成员重名，但它们不受重载函数。   
