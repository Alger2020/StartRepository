# 代码重用  
* 重用类代码  
	* 用类定义对象  
	* 通过组合定义新的类（称为组合类）
	* 通过继承定义新的类（称为派生类）
* 类的五大要素  
	* 数据成员  
	* 函数成员  
	* 访问权限   
	* 构造函数  
	* 析构函数  
# 类的组合  
* 组合的编程原理是：程序员在定义新类的时候，使用已有的类来定义数据成员。执行数据成员是类类型的对象，被称为类的**对象成员**。c++语言将数据成员中包含对象成员的类称为组合类  
* 按照数据类型的不同，组合类中数据成员可分为2种，即类类型的**对象成员**和级别数据类型的**非对象成员**  
* 使用组合类定义对象，即组合类对象，其成员中也将包含对象成员和非对象成员  
* 访问组合类对象中的非对象成员`组合类对象名.非对象成员名`   
* 组合类对象中的对象成员还包括自己的下级成员，也就是说组合类对象包含多级成员。可以访问组合类对象中对象成员的下级成员，这是一种多级访问。多级访问的语法形式是：`组合类对象名.对象成员名.对象成员的下级成员名`  
* 多级访问将受到多级权限的控制  
* 如何设计组合类中对象成员范围权限  
	* 组合类编程中有2种程序员角色，分别是定义组合类的程序员甲和使用组合类的程序员乙  
	* 甲在使用对象成员组装组合类时，可根据功能要求决定将哪些对象成员开放给乙，哪些隐藏起来。开放就是将对象成员设定为公有权限，隐藏就是设定为保护权限或所有权限，这就是对象成员的二次封装  
	* 乙使用组合类定义对象。在所定义出的组合类对象中，开放的对象成员可以访问，隐藏的则不可以访问。组合类对象中的对象成员还包含下级成员，这些下级成员也都有各自的访问权限，公有的才可以访问，否则不可以  
	* 多级访问将受到多级权限控制。访问组合类对象中对象成员的下级成员，只有对象成员和下级成员都是公有权限才可以访问，否则就不能访问   
* 组合类对象的构造与析构  
	* 对象的构造与析构  
	> 计算机执行定义对象语句时将创建对象，为其分配内存空间，并自动调用对象所属类的构造函数来初始化对象，这个过程就是对象的构造。当对象生存期结束时，计算机将销毁对象。销毁时自动调用对象所属类的析构函数来清理内存，然后释放其所占用的内存空间，这个过程就是对象的析构  	  
	* 组合类对象的构造与析构
		* 组合类的构造函数（先构造对象成员后构造非对象成员）  
		```  
		组合类构造函数名(形参列表):对象成员名1(形参1),对象成员名2(形参),......     //对象成员名里的形参来源形参列表    
		{
		......//在函数体中初始化其他非对象成员  
		}  
		```  
		* 组合类对象中各数据成员的初始化顺序是：先调用对象成员所属类的构造函数，初始化对象成员；再执行组合类构造函数的函数体，初始化其他非对象成员  
		* 如果组合类中有多个对象成员，那么这些对象成员的初始化顺序由其在组合类中的声明顺序决定，先声明者先初始化    

* 组合类的析构函数  
	* 当对象生存期结束时，计算机销毁对象，释放其内存空间，这个过程就是对象的析构。销毁对象时计算机会自动调用其所属类的析构函数  
	* 组合类对象中数据成员的析构顺序是：先执行组合类析构函数的函数体，清理非对象成员；再第哦啊有对象成员所属类的析构函数，清理对象成员  
	* 简单地说，对象的析构顺序与构造顺序相反，即先析构非对象成员，再析构对象成员   
* 类的组合与聚合  
	* 数据成员中包含对象成员的类称为组合类  
	* 数据成员中包含对象指针的类称为聚会类，聚合类是一种特殊形式的组合类   
* 聚合类与组合类的区别  
	* 集合类的对象成员是独立创建的，聚合类对象只包含指向对象成员的指针  
	* 聚合类对象可以共用对象成员   
* 组合类总结  
	* **代码重用** 组合类是一种有效的代码重用形式。程序员再设计新类的时候应先去了解有哪些可以重用的类。这些类可以是自己以前编写的，可以是集成开放环境IDE提供的，也可以是从市场上购买的。根据功能选择自己需要的类，然后用组合的方法定义新类   
	* **自低向上** 类可以多级组合。用零件类定义组合类，组合类可继续作为零件类去定义更大的组合类，这就是类的多级组合。多级组合是一种“自底向上”的程序设计方法。类越往上组合，其功能就越有针对性，应用面也就越窄。多级组合过程中，每一级组合类都会根据自己的功能需要设定对象成员的访问权限。有多少级组合，就有多少层封装    


# 类的继承与派生 
* 设计新类时可继承已有的类，这个已有的类被称为基类或父类  
* 基类是为解决以前的老问题而设计的，在面对新问题时其功能可能会显得不够完善。程序员需要在继承的基础上对基类进行派生，例如添加新功能，或者对从基类继承来的功能进行某些修改。派生的目的是为了解决新问题  
* 通过继承与派生所得到的新类被称为派生类或子类  
* 继承与派生的编程原理是：程序员在定义新类的时候，首先继承基类的数据成员和函数成员；在此基础上进行派生，为派生类添加新成员，或对从基类继承来的成员进行重新定义或修改其访问权限。在继承与派生的过程中，继承实现了基类代码的重用，派生则实现了基类代码的进化   
* 派生类中的成员可分为2种：一是从基类继承类的成员，称为派生类中的基类成员，二是定义时新增的成员，称为派生类中的新增成员  
* 定义派生类  
```c++  
class 派生类名:继承方式1 基类1,继承方式2 基类2，.......//派生类声明部分   
{
public:
	新增公有成员  
protected:
	新增包含成员  
private:
        新增私有成员   
}:
各新增函数成员的完整定义//派生类实现部分 
``` 
> * 定义派生类时，在派生类名的后面添加**继承列表**,在声明部分的大括号里声明**新增成员**，在实现部分编写各新增函数成员的完整定义代码；  
> * **继承列表**指定派生类从哪些基类继承。派生类可以只从一个基类继承（单继承），也可以从多个基类继承（多继承）。每个基类以“继承方式 基类名”的形式声明，多个基类之间用“,”隔开；  
> * 派生类将继承基类中**除构造函数、析构函数之外**的所有数据成员和函数成员。基类的构造函数和析构函数也不被继承，派生类需重新编写自己的构造函数|析构函数。    
> * 继承后，派生类会对其基类成员按照**继承方式**进行再次封装。继承方式有3种：publice(公有继承)、protected（保护继承）和private（私有继承）；  
> * public（公有继承）：派生类对其基类成员不做任何封装，他们在派生类中的访问权限与原来在基类的权限相同；  
> * private （私有继承）：派生类对其基类成员做全封装，他们在派生类中的访问权限统统被改为private（私有权限），不管它们原来在基类中的去啊那些是声明。使用私有继承，实际上是派生类要将其基类成员全部隐藏清理；  
> * protected（保护继承）：派生类对其基类成员做半封装。基类中的public成员被继承到派生类后，其访问权限被降格成protected（保护权限）。基类中的protected、private成员被继承到派生类后，其访问权限保持不变；  
> * 在**类声明部分**的大部分中声明新增的数据成员、函数成员，并指定各新增成员的访问权限。在类实现部分编写各新增函数成员的完整定义代码。  
* 同名覆盖:派生类中定义与基类成员重名的新增成员，新增成员将覆盖基类成员。通过成员名访问时，访问到的将是新增成员，这就是新增成员对基类成员的同名覆盖。同名覆盖后，被覆盖的基类成员仍然存在，只是被隐藏了。可以访问被覆盖的基类成员，其访问形式是：基类名::基类成员名     
* 如何数据派生类的继承方式  
	* 派生类编程中有2种程序员角色，分别是定义派生类的程序员甲和使用派生类的程序员乙。甲在设计派生类时需根据派生类的功能要求来决定：是将基类成员继续开放给乙，还是将它们隐藏起来。公有继承就是继续开放基类成员，私有继承或保护继承就是隐藏基类成员，这就是派生类对基类成员的二次封装  
	* 乙使用派生类定义对象，是否可以访问其中的基类成员，这取决于给基类成员的访问权限。派生类类对象中基类成员的访问权限由如下两个方面的因素决定：
		* 因素1：派生类的继承方式  
		* 因素2：基类成员原来在基类中的访问权限  
	* 派生类也可以任意多级。用基类定义派生类，派生类可以继续作为基类去定义更下级的派生类，这就是多级派生。多级派生过程中，每一级派生类都会根据自己的功能需要设定继承方式，这相当于对所继承的基类成员进行再次封装   
* 派生类的**保护继承**是向其下级派生类定向开放的一种半封装   
* 派生类对象的构造与析构  
	* 对象的构造与析构  
	> 计算机执行定义对象语句时将创建对象，为其分配内存空间，并自动调用对象所属类的构造还是来初始化对象，这个过程就是对象的构造。当对象生存期结束时，计算机将销毁对象。销毁时自动调用对象所属类的析构函数来清理内存，然后释放其所占用的内存空间，这个过程就是对象的析构   
* 派生类对象的构造与析构
	* 派生类的构造函数   
	```  
	派生类构造函数名(形参列表):基类名1(形参1),基类名2(形参2),......  
	{
	......//函数体中的初始化新增成员  
	}  
	```   
	> * 派生类对象各数据成员的初始化顺序时：先调用基类构造函数，初始化基类成员；再执行派生类构造函数的函数体，初始化新增成员   
	> * 如果派生类继承了多个基类，那么各基类成员的初始化顺序由其在派生了继承列表中的声明顺序决定，声明在前的基类成员先初始化   
* 派生类的析构函数  
	* 派生类对象中数据成员的析构顺序是：先执行派生类析构函数的函数体，清理新增成员；再调用基类析构函数，清理基类成员。简单来说，对象的析构顺序与构造顺序相反，即先析构新增成员，再析构基类成员  
* 组合派生类的构造与析构  
	* 从基类继承来的成（基类成员），二是新增的对象，三是新增的对象成员   
	* 组合派生类的构造函数需依次初始化基类成员、新增非对象成员。其中，初始化基类成员和新增对象从需通过初始化列表，初始化新增的非对象成员则是再函数体中直接赋值  
	* 组合派生类对象中各成员的析构顺序与其构造顺序相反，即先析构新增的非对象成员，再析构新增对象成员，最后才析构基类成员   

# 多态性  
* 多态性也是一个生物学概念，指的是生物会在不同层面上题型出多态性   
* 源程序中相同的程序元素可能会具有不同的语法解释，c++语言称这些元素具有多态性  
	* 关键字多态性、重载函数多态、运算符多态、对象多态、参数多态  
* 对具有多态性的程序元素作出最终明确的语法解释，这称为多态的实现  
* 不同多态形式具有不同的实现时间点，编译时实现的多态称为编译时多态，执行时实现的多态称为执行时多态  
* 重新定义c++语言已有运算符的运算规则，使同一运算符作用于不同类型时间时执行不同的运算，这就是运算符重载  
	* 程序员可以为类重载运算符，实现类运算  
	* 重载运算符使用函数的形式来定义运算符的运算规则  
``` 
函数类型 operator 运算符(形式参数) 
{  函数体 }  
``` 
	* 将运算符函数定义为类的函数成员  
	* 定义为类外的一个友元函数  
* 运算符重载的语法细则：
	* 除了下面的5个运算符，c++语言中的其他运算符都可以重载。5个不能重载的运算符时：条件运算符“?:"、sizeof运算符、成员运算符“.”、指针运算符“*”和作用域运算符“::”   
	* 重载后，运算符的优先级和结合性不会变   
	* 重载后，运算符的操作数个数不能改变，同时至少要有一个操作数是自定义数据类型  
	* 重载后，运算符的含义应与原运算符相似，否则会给使用类的程序员造成困惑   
* 对象的替换与多态  
	* 派生类是一种基类， 具有基类的所有功能  
	* 面对对象程序设计利用派生类和基类之间的这种特殊关系，常常将派生类对象当作基类对象来使用，或者用基类来代表派生类，其目的是为提高程序代码的可重用性   
* 对象的换与多态  
	* 在面对对象程序设计中，重用处理基类对象的程序代码来处理派生了对象，这是非常普遍的需求  
	* 如果派生类对象能够与基类对象一起共用程序代码，它将极大地提高程序开发和维护的效率  
	* 面对对象程序设计方法利用派生类和基类之间存在的特殊关系，提出了对象的替换与多态  
		* Liskov替换准则：将派生类对象当作基类对象来使用  
		* 对象多态性：用基类来代表派生类     
* 基类及其下面的各级派生类共同组成了一个具有继承关系和共同特性的类的家族，我们称之为族类   
* Liskov替换准则    
	*为了让基类对象及其派生类对象之间可以重用代码，c++语言制定了如下的类型兼容语法规则：  	  
	> * 派生了对象可以赋值给基类对象；  
	> * 派生类的对象可以初始化基类引用；  
	> * 派生类对象的地址可以赋值给基类的对象指针，或者说基类的对象指针可以指向派生类对象。   
	* 应用类型兼容语法规则有1格前提条件和1个使用限制：  
	> * 前提条件：派生了必须公有继承基类。  
	> * 使用限制：通过基类对象、引用或对象指针访问派生类对象，只能访问其基类成员     
* 什么是对象多态性   
	* 面向对象程序设计借用拟人化的说法，将调用对象的某个函数成员称为向对象发送一条消息   
	* 将执行函数成员完成某种程序功能称为对象响应该消息所表现的行为  
	* 不同对象接收相同的消息，但会表现出不同的行为，这就称对象的多态性，或称对象具有多态性   
	* 从程序角度，对象多态性就是：调用不同对象的同名函数成员，但所执行的函数不同，完成的程序功能不同。导致对象多态性同名函数成员有3种不同形式：  
		* 不同类之间的同名函数成员。类成员具有类作用域，不同类之间的函数成员可以重名，互不干扰。   
		* 类中的重载函数。类中的函数成员之间可以重名，只要他们的形参个数不同，或类型不带。重载函数成员导致多态在本质上属于重载函数多态。    
		* 派生了中的他们覆盖。派生类中新增的函数成员可以与从基类继承类的函数成员重名，但它们不是重载函数。
* 应用Liskov替换准则，将派生类对象当作基类对象类处理，急用基类对象替换派生类对象。其目的是然某些处理基类对象的代码可以被派生类对象重用。这里的”某些“代码的含义是：这些代码在通过基类的引用或对象指针访问派生类地下时，只需访问其基类成员   
```  
viod SetGMT(clock &robj,int hGMT,int mGMT,int sGMT)  
{
rObj.Set(hGMT+8,mGMT,sGMT);//不管是基类或派生类对象，都调用基类成员Set   
}  
```   
* 还有”另外一些"代码：这些代码在通过基类的引用或对象指针访问同一类族的对象时，，需根据实际引用或指向的对象类型，自动调用该类它们函数成员:自动调用该类同名好函数成员中的新增成员（而不是基类成员）  
``` 
void ShowBeijing (Cloc &rObj)  
{
rObj.Show();//希望能区分基类和派生了对象，自动调用对应的成员  
cout<<"北京时间“;
}   
```  
* 应用对象多态性：相当于是用基类来代表派生了。通过基类引用或对对象指针调用派生类对象的函数成员，应能够根据实际引用或指向的对象类型，自动调用该类同名函数成员中的新增成员  
* c++语言使用虚函数的语法形式来实现类族中对象的多态性  
* 实现对象多态性  
	* 首先，在定义基类时使用”virtual"关键字将函数成员声明成虚函数  
	* 然后通过公有继承定义派生类，并重写虚函数成员，也就是新增1个与虚函数同名的函数成员  
	* 使用基类引用或对象指针  
		* 调用基类对象的函数成员：自动调用基类成员  
		* 调用派生类对象的函数成员  
			* 普通函数成员：自动调用基类成员   
			* 虚函数成员：自动调用派生类成员   
* 虚函数的声明与调用   
```c++   
class A  //基类A  
{
public:  
	virtual void fun1();  //函数成员fun1被声明为虚函数   
	void fun2();//函数成员fun2被声明为非虚函数  
}:
void A::fun1(){cout<<"base class A:virtual fun1()called."<<endl;}  
void A::fun2(){cout<<"base class A:non-virtual fun2()called.“<<endl;}  

class B:public A  //派生类B   
{
public:  
	virtual void fun1();  //重写基类的虚函数成员fun1   
	void fun2();//重写基类的非虚函数成员fun2  
};  
void B::fun1(){cout<<"derived class B:virtual fun1()called."<<endl;}  
void B::fun2() {cout<<"derved class B:non_virtual fun2()called."<<endl;  }  
```   
* 声明虚函数的语法细则  
	* 只能在类声明部分声明虚函数。在类声明部分定义函数成员时不能使用”virtual"关键字   
	* 基类中声明的虚函数成员被继承到派生类后，自动成为派生类的虚函数成员  
	* 派生类可以重写基类虚函数成员。如果重写后的函数原型与基类虚函数成员完全一致，则该函数自动成为派生类的虚函数，无论声明时加不加“virtual"关键字  
	* 类函数成员中的静态函数、构造函数不能时虚函数。析构函数可以是虚函数    
* 程序员概念如何应用对象的替换与多态来提高程序代码的可重用性。为了让某个类族共用程序代码：  
	* 定义基类时首先需确定将哪些函数成员声明成虚函数，将需要自动调用派生类新增的同名函数成员定义成虚函数  
	* 定义派生类时公有继承基类，并重写那些从基类继承来的虚函数成员   
	* 编写类族共用的程序代码时，需定义基类引用或对象指针来访问该类族的对象（不管是基类对象，还是派生类对象），然后通过基类引用或对象指针来调用派生类对象的的还是成员，调用虚函数将自动调用派生类中重写的虚函数，否则将调用从基类继承来的还是成员   
* 类定义中，”只声明，未定义“的函数成员被称未纯虚函数  
* 含有纯虚函数成员的类就是抽象类  
	* 抽象类不能实例化  
	>不能使用抽象类定义对象（即不能实例化），因为抽象类中含有未定义的纯虚函数，其类型定义还不完整。但可以定义抽象类的引用、对象指针，所定义的引用、对象指针可以引用或指向其派生类的实例化对象。      
	* 抽象类可以作为基类定义派生类  
		* 抽象类可以作为基类定义派生类。派生类继承抽象类中除构造函数、析构函数之外的所有成员，包括纯虚函数成员    
		* 纯虚函数成员只声明了函数原型，没有定义函数体代码。因此派生类继承纯虚函数成员时，只是继承其函数成员，即函数接口。派生类销毁为纯虚函数成员编写函数体代码，称为实现纯虚函数成员  
		* 派生类如果实现了所有的纯虚函数成员，那么它就变成了一个普通的类，可以实例化    
* 抽象类的应用   
*	* 统一类接口   
	> 通常，派生类继承基类是为了重用基类的代码。如果基类是抽象类，其中的纯虚函数成员并没有定义函数体代码，只声明了函数原型。基类声明纯函数成员的目的不是为了重用其代码，而是为了统一类族对外的接口。在基类中声明纯虚函数重用，各派生类按照各自的功能要求实现这些纯虚函数，这样类族中所有的派生类都具有相同的接口   
	* 重用代码  
	> 抽象类中定义的纯虚函数具有虚函数的特性，调用时具有多态性。在基类中声明纯虚函数成员的另一个目的是利用虚函数调用时的多态性，让类族中的所有派生类对象可以重用相同的代码    
* 派生类可以从多个基类继承，这就是多继承。多继承派生类存在比较复杂的重用重名问题，其具体表现形式有3种：
	* 新增成员与基类成员重名。在新增成员与基类成员重名的情况下访问派生类对象，所访问到的是新增成员，还是基类成员？这要由访问形式来决定：  
		* 如果通过派生类的对象名、引用或对象指针访问派生类对象，则访问到的是新增成员，此时新增成员覆盖同名的基类成员（同名覆盖）。   
		* 如果通过基类的对象名、引用或对象指针访问派生类对象，则访问到的是基类成员。此时派生类对象被当作基类对象使用（Liskov替换准则）。 
		* 如果基类定义虚函数成员，派生类公有继承基类并重写虚函数（属于新增成员），那么通过基类的引用或对象指针访问派生类对象所访问到的将是新增的虚函数成员。这就是调用对象中虚函数成员是所呈现出的多态性（对象多态性）。    
	* 多个基类之间的成员重名。 如果多个基类之间有重名的成员，同时继承这些基类会造成派生类中基类成员之间的重名。    
	* 同一个基类被重复继承。多级派生时，从同一个基类派生出多个派生类，这多个派生类再被多继承到同一个下级派生类。该下级派生类将包含多份基类成员的拷贝，也就是同一基类被重复继承   
* 类的继承与派生主要有2个作用：  
	* 重用类代码。派生类继承基类，就是重用基类的代码，使用其功能，从而提高程序的开放效率  
	* 统一类族接口。抽象类中包含纯虚函数成员。纯虚函数只声明函数原型，没有定义代码，没有实现任何功能。如果基类是抽象类，在基类中声明纯虚函数成员，其派生类按照各自的功能要求声明这些纯虚函数。这样以该基类为根的类族中的所有派生类都将具有相同的对外接口，更便于类族的使用    
* Java和c#语言  	
	* 只允许单继承。派生类只能继承一个基类，即只能重用一个基类的代码  
	* 但为了统一类族接口，它们引入了一个新的概念：接口    








	
