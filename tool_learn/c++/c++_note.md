# 类的定义  

## c++语法：定义类  
``` c++
 class 类名 //类声明(Declaration)部分  
{
public:  
	公有成员  
protected:  
	保护成员  
private:  
	私有成员  
}；  

 各函数成员的完整定义 //类实现(Implementation)部分  
```  
 ******  
### 语法说明  
* **class**是定义类时的关键字；  
* **类名**需要符号标识符的命名规则；  
* **类成员**有两种，分别是数据成员和函数成员。某些特殊的 类可能只包含1种成员，比如只包含数据成员，或只包含函数成员；  
* **访问权限**有3种，分别是public(公有权限)、protected(保护权限)和private(私有权限);  
* **类定义代码**分为2个部分。**类声明部分**在大括号中声明数据成员、函数成员，并指定各成员的访问权限。声明数据成员的语法形式类似于定义变量语句，但声明时不能初始化。声明函数成员只是声明其原型，完整的函数定义代码放在大括号外面的**类实现部分**，定义时需在函数名前加“类名::”限定，指明该函数属于哪个类；  
* 函数成员可以访问本类中任意位置的数据成员，或调用本类中任意位置的函数成员。类成员之间相互访问不需要“先定义，后访问”，或“先声明，后访问”，不受权限约束。在类定义代码（包括声明和实现2部分）范围内，任何类成员都可以被本类的其他成员访问，类成员具有**类作用域(Class scope)**;  
* 不同类作用域之间的标识符可以重名，即不同类的成员之间可以重名。    

### 示例  
```c++  
class ABC  //类声明部分  
{
	int d0;  //int型数据成员d0，未指定访问权限时默认为private  
public:
	float d1;  //float型数据成员d1，访问权限为public  
	void fun1();  //函数成员fun1,默认为其前一个成员的权限，即public  
protected:
	bool d2;  //bool型数据成员d2，访问权限为protected  
	void fun2 (char ch); //函数成员fun2默认为其前一个成员的权限，即protected  
private:  
	cha d3,str[10];  //char型数据成员d3和str(数组)，访问权限为private  
	int fun3();  //函数成员fun3，默认为其前一个成员的权限，即private  
};

//类实现部分  
void ABC::fun1() {......} //函数成员fun1的完整定义代码  
void ABC::fun2(char ch) {......} //函数成员fun2的完整定义代码  
int ABC::fun3() {......} //函数成员fun3的完整定义代码 
``` 
### 数据成员的语法细则  
* 数据成员也称为属性，是类中的变量，用于保存数据。  
* 数据成员的类型可以是基本数据类型，也可以是自定义数据类型。  
* 不同数据成员之间的类型可以相同，也可以不同。  
* 数据成员不要与其他成员重名。  
* 声明数据成员的语法类似于定义变量，所不同的是**声明数据成员不能初始化**。  

### 函数成员的语法细则  
* 函数成员也称为方法，是类中的函数，其功能是对本类中的数据成员进行处理。  
* 函数成员可直接访问本类中的数据成员，数据成员相当于是类中的全局变量。函数成员可以直接调用本类中的其他函数成员。  
* 在类的声明函数成员时可以指定形参的默认值，级带默认形参值的函数。  
* 不同函数成员之间可以重名，即重载函数。两个函数的形参个数不同，后数据类型不同，那么这两个函数就可以重载。函数成员不能与数据成员重名。  
* 可以将函数成员定义成内联函数。在**类实现部分**定义函数成员时可以用“inline”关键字将其定义成内联函数，或者直接将该函数成员定义在类声明部分的大括号里。C++编译器默认将直接定义在类声明部分大括号里的函数成员当做内联函数处理。  

### 访问权限的语法细则  
* 每个类成员都有并且只有一种访问权限。  
* 定义类时，不同权限成员可以按容易次序编排。为便于阅读，通常将相同权限的成员编排在一起；或将数据成员编排在一起，将函数成员编排在一起。  
* 关键字`public``protected`private`指定了其后续成员的访问权限。在类声明中，同一关键字可出现多次，也可以不出现（如果没有该访问权限的成员）。通常，一个类需保护公有权限的成员，否则该类没有对外的接口，无法使用。  



## 类与对象的编译原理    
* 类代码的编译  
```c++  
//函数成员CArea:调整前  
double Circle::CArea()//求面积  
{
	return (3.14*r*r);
}  
//调整后  
double Circle::CArea(Circle* const this)
{
	return (3.14*this->r*this->r);
}

//函数成员Show:调整前  
doble Circle::Show()//显示面积和周长  
{
	cout<<CArea()<<endl;  
	cout<<CLen()<<endl;  
}  
//调整后  
double Circle::Show(Circle* const this)
{
	cout<<this->CArea()<<endl;  
	cout<<this->Clen()<<endl;  
}  
```
* 对象创建  
> 每个对象所占用的内存空间都等于类中全部数据成员所需内存空间的总和    
> 多个同类对象共用同一个函数，内存中只需要保存一份函数代码   
* 调用对象函数成员语句的编译  
```c++  
Circle obj1;
obj1.Input();  
//编译器对其函数进行调整处理，如下  
Input(&obj1);  

void Circle::Input(Circle * const this) 
{cin>>this->r;}  
```  


## 对象的构造与析构  
* 计算机创建对象为对象分配内存空间称为对象的**构造**，当对象生存期结束计算机销毁对象释放其内存空间称为对象的**析构**  
* 构造个性化对象  
	* 初始化对象  
	* 显示对象构造过程  
	* 构造时申请额外的内存  
* 销毁个性化内存  
	* 释放额外申请的内存  
* **构造函数**  
	* 构造函数必须与类名相同。  
	* 构造函数由计算机自动调用，程序员不能直接调用。  
	* 构造函数通过形参传递初始值（可指定默认形参值），实现对新建对象数据成员的初始化。  
	* 构造函数可以重载，即定义多个同名的构造函数，这样可提供多种形式的对象构造方法。  
	* 构造函数可以定义成内联函数。  
	* 构造函数没有返回值，定义时不能写函数类型，写void也不行。  
	* 构造函数通常是类外调用，其访问权限应设为public或protected，不能设为private。  
	* 一个类如果没有定义构造函数，编译器在编译时将自动添加一个空的构造函数，称为默认构造函数，其形式为：类名(){}  
* ***初始化对象***  
```c++  
Circle::Circle(double x)  //带形参的构造函数  
{	r=x;   }  
Cricle::circle()  //不带形参的构造函数  
{	r=0;	}  
Circle::Circle(Circle &obj)  
{	r = obj.r;	}  //拷贝构造函数  


//例
Circle obj(5.0);  
circle obj;
Circle obj1(5.0);  
Circle obj2(obj1);  
```  
* ***显示对象的构造过程***  
```c++  
Circle::Circle()  //不带形参的构造函数  
{	r=0；cout<<"Circle()callde."<<endl;}
Circle::Circle(double x)  //带形参的构造函数  
{	r=x; cout<<"Circle(double x)called."<<endl; }  
Circle::Circle(Circle &obj)  //拷贝构造函数  
{	r=obj.r; cout<<"Circle(Circle &obj)called."<<end;  }  

//例  
Circle obj;  //显示信息：Circle()called.  
Circle obj1(5.0);  //显示信息：Circle(double x)called.  
Circle obj2(obj1):  //显示信息：Circle(Circle &obj)called.  
```
* ***构造对象时申请额外内存***  
```c++  
class Student //定义一个学生信息类Student  
{
publice:  
	char Name[9],ID[11];  //保存姓名和学号的字符数组Name、ID  
	int Age;  //保存年龄的int型数据成员Age  
	double Score；  //保存创建的double型数据成员Score  
	char * Memo;  //备注成员  
	Student(char* pName,char* pID, int iniAge,double iniScore,char *pMemo)  //内联构造函数
{
	strcpy(Name,pName); strcpy(ID,pID);//初始化姓名，学号  
	Age = iniAge; Score = iniScore;//初始化年龄、成绩   
	int len =strlen(pMemo);  //计算实际传递来的备注信息长度  
	if (len<=0) Memo=0;//没有备注信息。0表示空指针  
	else 
{
	Memo=new char[len+1];//按照实际长度分配内存  
	strcpy(Memo,pMemo);//初始化备注信息  
}
}
}；
//......其他函数成员省略   

//例  
Student obj1("张三","1400500001",19,95,"");  
Student obj2("张三","1400500001",19,95,"市级三好学生");  
```   
* **析构函数**  
	* 析构函数名必须为"~类名".  
	* 析构函数由计算机自动调用，程序员不能直接调用。  
	* 析构函数没有形参。  
	* 析构函数没有返回值，定义时不能写函数类型，写void也不行。  
	* 一个类只能有***一个***析构函数。  
	* 析构函数通常时类外调用，其访问权限应设为public或protected，不能设为private。   
	* 一个类如果没有定义析构函数，编译器在编译时将自动添加一个空的析构函数，称为默认析构函数，其形式为：~类名(){}    
	```c++ 
	Student ()   
	{  
		if(Memo!=0)delete[]Memo;  
	}  
	```
* 拷贝构造函数中的深拷贝与浅拷贝  
```c++  
//接上面例子  
Student obj3(obj2);//将自动调用默认拷贝构造函数  

Student (Student &obj)//默认拷贝构造函数  
{
         char Name[9],ID[11];  //保存姓名和学号的字符数组Name、ID
         int Age;  //保存年龄的int型数据成员Age
         double Score；  //保存创建的double型数据成员Score
         char * Memo;  //备注成员

	strpy(Name,obj.Name);strcpy(ID,obj.ID);//拷贝姓名学号   
	Age=obj.Age;  Score=obj.Score;//拷贝年龄、成绩  
	Memo=obj.Memo;//拷贝备注信息，注：并没有再分配内存  	
}      //此为浅拷贝，并没有将obj2的信息完全的拷贝一份，Memo共用指针   
//深拷贝如下，将obj2.Memo内容完全拷贝一份  
 Student (Student &obj)//深拷贝构造函数  
{
         char Name[9],ID[11];  //保存姓名和学号的字符数组Name、ID
         int Age;  //保存年龄的int型数据成员Age
         double Score；  //保存创建的double型数据成员Score
         char * Memo;  //备注成员
	int len=strlen(obj.Memo);//计算obj所引用的备注信息长度  
	if (len<=0) Memo=0;//没有备注信息。0表示空指针  
	else 
	{
		Memo=new char [len+];//按照实际长度分配内存9(需加1个结束符‘\0')  
		strcpy(Memo,obj.Memo);//拷贝obj所引用对象的备注信息  
	}
}  
```  

## 类与对象编程的主要内容  
* 定义类。程序员在定义一个类的时候要考虑到5大要素，即数据成员、函数成员、各成员的访问权限、构造函数和析构函数。  
* 定义对象。将类当作一种自定义数据类型来定义变量，所定义的变量称为对象。计算机执行定义对象语句就是严格按照类所描述的5大要素在内存中创建类的对象，所创建的对象具有类所规定的实际成员、函数成员及访问权限。  
* 访问对象。访问对象就是提供接口（即公有成员）操作内存中的对象，实现特定的程序功能，比如读写对象中的公有数据成员，或调用其中的公有函数成员。  

## 类中的常成员与静态成员  
* const数据保护机制  
	* 常数据成员、常函数成员  
* static静态机制  
	* 静态数据成员、静态函数成员  
* ***常数据成员的语法细则***  
	* **关键字const** 在类定义中声明常数据成员需使用关键字const进行限定，声明时不能初始化  
	```c++  
	private:  
		const double price;  
	```
	* **初始化列表** 类中的任何函数都不能对常数据成员赋值，包括构造函数。为构造函数添加初始化列表是对常函数成员进行初始化的唯一途径。在构造函数的函数头后面添加初始化列表： 
	```c++
	构造函数名(形参列表)：常数据成员名1(形参1）,常数据成员名2(形参2),......
	{  
		......//在函数体中初始化其他数据成员  
	}  
	//形参1、形参2等是从形参列表中提取出来的，并在初始化列表中进行二次接力传递
	```   
	* **定义对象时初始化** 定义含常数据成员类的对象时需要初始化，给出常数据成员的初始值
* ***常函数成员的语法细则***  
	```c++  
	//内联函数  
	double GetCost()const{return (3.14*r*r*price);}  

	//非内联函数  
	double GetCost()const;//声明  

	double CirclePool::GetCost()const  //实现  
	{return (3.14*r*R*price);}  
	```  
	* 声明、定义常函数成员需在函数头后面加关键字const进行限定  
	* 常函数成员只能读类中的数据成员，不能赋值修改  
	* 常函数成员只能调用其他常函数成员。换句话说，常函数成员不能调用其他无const限定的函数成员，以防这些函数间接修改了数据成员  
	* 通过常对象只能调用其常函数成员。换句话说，通过常对象不能调用无const限定的函数成员，以防这些函数间接修改了常对象的数据成员  
	* 除形参个数、类型之外，还可以用关键字const区分类中的重载函数  

* ***静态数据成员的语法细则***  
	* **关键字static** 在类定义中声明静态数据成员需使用关键字static进行限定，声明时不能初始化。  
	* **定义及初始化** 必须在类声明的大括号外面（通常是和函数成员定义一起放在类实现部分）对静态成员进行定义，定义时不能再加关键字static。定义时可以初始化。  
	* **在同类函数成员中访问** 在同类的函数成员中访问静态数据成员直接使用其成员名访问，访问时不受权限约束   
	* **在类外其他函数中访问** 在类外其他函数（例如主函数）中访问静态数据成员需以“类名：：静态数据成员名”的形式访问。类外访问权限受约束，只能访问公有的静态数据成员  
	* **生存期及作用域** 和全局变量一样，静态数据成员是静态分配的，程序加载后立即分配内存，直到程序执行结束退出时才被释放。访问权限决定静态数据成员的作用域。私有静态数据成员具有类作用域，只能在类内访问。公有静态数据成员具有文件作用域，可以被本文件中的任何函数访问，并且可通过类声明将其作用域扩展到任何程序文件  
	```c++   	
	class CirclePool 
	{
	private:  
	static double price;
	//其他省略   
	} ;  

	double CirclePool::price=10;//在类外定义、初始化，定义时加“类名::”  
	```      
* ***静态函数成员的语法细则***  
	* 声明时使用关键字static进行限定，定义时不能再使用关键字static  
	* 静态函数成员只能访问类中的静态数据成员，因为静态函数成员可以不定义对象直接调用，而非静态数据成员只有在定义对象后才分配内存空间，才能访问。同样道理，静态函数成员不能调用其他非静态函数成员。  
	* 类中的其他函数成员调用静态函数成员直接使用其函数成员名调用，调用时不受权限约束   
	* 在类外调用静态函数成员需以“类名::静态函数成员()”的形式调用，或通过任何一个该类对象以“对象名.静态函数成员名()”的形式调用。类外调用受权限约束，只能调用公有的静态函数成员  
	* 静态函数成员不能是内联函数，因为编译器在编译是会调整内联函数，此时所访问的静态数据成员可能还没初始化，因此其数据是不可靠的，此时访问会导致程序运行结果出差  
	```c++  
	static double GetPrice(); //声明  
	
	double CirclePool::GetPrice()  //实现  
	{return price;}  
	```
## 友元函数  
* **在类中声明友元函数**  
```c++ 
class 类名  //类声明部分  
{
	......
	friend 友元函数的原型声明;  
}；
```  
* 语法声明：  
	* 在**类声明部分**声明友元函数的原型，声明时使用“friend”关键字。声明语句可以放在大括号内的任意位置，该位置的访问权限与友元函数无关；  
	* **友元函数**是类外的其他函数，不是类的成员；  
	* **友元函数**可以在其函数体内访问该给对象的所有成员，不受权限约束。   
  
* **在类中声明友元类**  
```c++  
class B  
{
....
void fun1(){}
void fun2(){}
};

class A
{
......
friend void B::fun1();//声明类B的函数成员fun1为类A的友元函数  
};  

class A
{
......  
friend class B;//声明类B为类A的友元类  
};
```  
	* **友元关系是单向的** 若类A声明类B是直接的友元，并不意味着自己同时成为对方的友元，除非对方声明自己是它的友元  
	* **友元关系不能传递** 假设类B是类A的友元，类C又是类B的友元，这并不意味着类A和类C之间存在任何友元关系，除非它们自己单独声明   














	
