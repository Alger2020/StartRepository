# 类的定义  

## c++语法：定义类  
``` c++
 class 类名 //类声明(Declaration)部分  
{
public:  
	公有成员  
protected:  
	保护成员  
private:  
	私有成员  
}；  

 各函数成员的完整定义 //类实现(Implementation)部分  
```  
 ******  
### 语法说明  
* **class**是定义类时的关键字；  
* **类名**需要符号标识符的命名规则；  
* **类成员**有两种，分别是数据成员和函数成员。某些特殊的 类可能只包含1种成员，比如只包含数据成员，或只包含函数成员；  
* **访问权限**有3种，分别是public(公有权限)、protected(保护权限)和private(私有权限);  
* **类定义代码**分为2个部分。**类声明部分**在大括号中声明数据成员、函数成员，并指定各成员的访问权限。声明数据成员的语法形式类似于定义变量语句，但声明时不能初始化。声明函数成员只是声明其原型，完整的函数定义代码放在大括号外面的**类实现部分**，定义时需在函数名前加“类名::”限定，指明该函数属于哪个类；  
* 函数成员可以访问本类中任意位置的数据成员，或调用本类中任意位置的函数成员。类成员之间相互访问不需要“先定义，后访问”，或“先声明，后访问”，不受权限约束。在类定义代码（包括声明和实现2部分）范围内，任何类成员都可以被本类的其他成员访问，类成员具有**类作用域(Class scope)**;  
* 不同类作用域之间的标识符可以重名，即不同类的成员之间可以重名。    

### 示例  
```c++  
class ABC  //类声明部分  
{
	int d0;  //int型数据成员d0，未指定访问权限时默认为private  
public:
	float d1;  //float型数据成员d1，访问权限为public  
	void fun1();  //函数成员fun1,默认为其前一个成员的权限，即public  
protected:
	bool d2;  //bool型数据成员d2，访问权限为protected  
	void fun2 (char ch); //函数成员fun2默认为其前一个成员的权限，即protected  
private:  
	cha d3,str[10];  //char型数据成员d3和str(数组)，访问权限为private  
	int fun3();  //函数成员fun3，默认为其前一个成员的权限，即private  
};

//类实现部分  
void ABC::fun1() {......} //函数成员fun1的完整定义代码  
void ABC::fun2(char ch) {......} //函数成员fun2的完整定义代码  
int ABC::fun3() {......} //函数成员fun3的完整定义代码 
``` 
### 数据成员的语法细则  
* 数据成员也称为属性，是类中的变量，用于保存数据。  
* 数据成员的类型可以是基本数据类型，也可以是自定义数据类型。  
* 不同数据成员之间的类型可以相同，也可以不同。  
* 数据成员不要与其他成员重名。  
* 声明数据成员的语法类似于定义变量，所不同的是**声明数据成员不能初始化**。  

### 函数成员的语法细则  
* 函数成员也称为方法，是类中的函数，其功能是对本类中的数据成员进行处理。  
* 函数成员可直接访问本类中的数据成员，数据成员相当于是类中的全局变量。函数成员可以直接调用本类中的其他函数成员。  
* 在类的声明函数成员时可以指定形参的默认值，级带默认形参值的函数。  
* 不同函数成员之间可以重名，即重载函数。两个函数的形参个数不同，后数据类型不同，那么这两个函数就可以重载。函数成员不能与数据成员重名。  
* 可以将函数成员定义成内联函数。在**类实现部分**定义函数成员时可以用“inline”关键字将其定义成内联函数，或者直接将该函数成员定义在类声明部分的大括号里。C++编译器默认将直接定义在类声明部分大括号里的函数成员当做内联函数处理。  

### 访问权限的语法细则  
* 每个类成员都有并且只有一种访问权限。  
* 定义类时，不同权限成员可以按容易次序编排。为便于阅读，通常将相同权限的成员编排在一起；或将数据成员编排在一起，将函数成员编排在一起。  
* 关键字`public``protected`private`指定了其后续成员的访问权限。在类声明中，同一关键字可出现多次，也可以不出现（如果没有该访问权限的成员）。通常，一个类需保护公有权限的成员，否则该类没有对外的接口，无法使用。  










# C++语言对C语言语法的扩充  
## 1. 数据的输入与输出  
* ### C语言的输入输出  
	* 输入/输出函数，例如`scanf`、`printf`等  
	* 头文件:`#include<stdio.h>`  

* ### C++语言的输入与输出  
	* 将提供输入数据的数据源称作输入数据流   
	* 将输出数据时的目的地称作输出数据流  
	* 输入数据流和输出数据流统称为输入/输出流  

* ### 标准输入/输出流  
	* 键盘（cin）、显示器（cout）  	
	* 相关声明语句  
	> #include<iostream>  //标准输入/输出流的头文件  
	> using namespace std;  //声明命名空间std    

## 2. 变量初始化及常变量  
* ### 变量初始化  
	int x=10,y;  //c语言风格  
	int x(19),y;  //c++语言风格  

* ### C语言中的符号常量  
	`#define PI 3.14`  

* ### C++语言引入了常变量   
	`const 数据类型 常变量名 = 初始值  `
	* 使用const关键字指定常变量；
	* 定义常变量时**必须初始化**；
	* 常变量的值不能被改变，例如不能被再次赋值。  
  
## 3. 引用及函数间参数的引用传递  
* ### 访问变量内存单元  
	假设，已定义变量：int x=10;  
	* 变量名访问：cout<<x;  
	* 指针访问：int* p; p=&x; cout<<(*p);  
	* C++语言新增了引用访问  

* ### 变量的直接访问与间接访问  
	引用与指针访问都是间接访问  

* ### 引用  
	`引用类型& 引用变量 = 被引用变量名;`  
	`int& xa =x;  cout<<xa;`  
	* **引用类型**是引用变量的数据类型，必须与被引用变量的类型一致；  
	* **&**是引用变量说明符，定义变量语句中，变量名前加"&"表示该变量为引用变量；  
	* **引用变量名**需符号标识符的命名规则；  
	* **被引用变量名**指定被引用的变量，改变量必须是一个已经定义的变量；  
	* 定义引用变量时必须初始化，即指定其是哪个变量的引用，引用变量只能引用一个变量，定义后不能在引用其他变量。  

* ### 函数间参数的传递  
	* 值传递  
	* 指针传递    
	`void swap(int* a, int& b);`  
	* 引用传递  
	`void swap(int& a, int& b);`
	* 引用传递特点  
		* 引用传递将被调函数的形参定义成主调函数中实参变量的引用，被调函数通过该引用间接访问主调函数中的变量。  
		* 被调函数修改形参实际上修改的是对应的实参。换句话说，主调函数可以通过引用将数据传给被调函数，被调函数也可以通过该引用修改实参的值将数据传回主调函数。引用传递是一种双向数据传递机制。
		* 引用传递时，实参必须是变量。  
		*引用传递的好处：一是形参直接引用实参，不需分配内存、传递数值，这样可以提高函数调用速度，减低内存占用；二是可以通过引用实现双向数据传递。

## 4. 几种特殊形式的函数  
* ### 带默认参数值函数的语法细则  
	* 带默认值的形参——调用是然后给实参则将实参值赋给形参，否则把默认值赋给形参。其他不带默认值的形参必须给出实参，否则语法错误。
	* 在函数原型声明中指定默认值——如果函数定义在调用语句之后，应该对函数原型进行声明，可以在声明中指定形参的默认值，此时函数定义中不能再指定默认值。函数具有文件作用域，同一函数在同一作用域中只能指定一次默认值；如果函数定义在其他文件中，应该在调用语句之前声明外部函数的原型，可以在声明语句指定形参在本文件的默认值，并且可以与原函数的默认值不同。  
	* 同一函数在不同作用域中可以指定不同的默认值  
	* 带默认值的形参必须定义在形参列表的后面    

* ### 重载函数  
	* C语言中的函数不能重名  
	* C++
	> 如果两个函数的形参个数不，或数据类型不同，那么这两个函数就可以重名。重名的函数被称为重载函数  
